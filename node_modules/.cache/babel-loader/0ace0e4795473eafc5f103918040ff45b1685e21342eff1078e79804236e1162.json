{"ast":null,"code":"import { gsap } from \"gsap\";\n// func\nimport { openCard, cardToSelf } from \"./cardUtils\";\n/**\r\n * Плавное перемещение элемента в заданную позицию с использованием gsap.\r\n * @param {HTMLElement} element - Элемент для анимации.\r\n * @param {number} toX - Конечное значение по оси X.\r\n * @param {number} toY - Конечное значение по оси Y.\r\n * @param {number} [toScale=1] - Конечный масштаб (по умолчанию 1).\r\n * @param {number} duration - Продолжительность анимации.\r\n * @param {number} delay - Задержка перед началом анимации.\r\n */\n\n// Анимация перемещения карты\nexport const animateMoveTo = (element, toX, toY, toScale = 1, duration, delay, rotation = true) => {\n  return new Promise(resolve => {\n    if (element) {\n      const currentScale = gsap.getProperty(element, \"scale\");\n      const currentX = gsap.getProperty(element, \"x\");\n      const currentY = gsap.getProperty(element, \"y\");\n      const rect = element.getBoundingClientRect();\n      gsap.fromTo(element, {\n        x: rect.x,\n        y: rect.y,\n        scale: currentScale,\n        opacity: 1,\n        rotate: 0\n      }, {\n        x: toX == null ? currentX : toX,\n        y: toY == null ? currentY : toY,\n        scale: toScale,\n        opacity: 1,\n        rotate: rotation ? 368 : -8,\n        duration: duration,\n        delay: delay,\n        ease: \"power2.out\",\n        onComplete: resolve // Разрешаем промис по завершению анимации\n      });\n    } else {\n      resolve(); // Если элемент не существует, сразу разрешаем промис\n    }\n  });\n};\n\n// Анимация получения карт игроком\nexport const animateGetCardsPlayerSelf = (elements, toX, toY, toScale = 1, duration, delay = 0, rotation = true) => {\n  if (elements.length > 0) {\n    const promises = elements.map((element, index) => {\n      if (element) {\n        const rect = element.getBoundingClientRect();\n        const elementWidth = rect.width;\n        const elementHeight = rect.height;\n        const offsetX = elementWidth * 0.5 * index;\n        const zIndex = elements.length - index;\n        return new Promise(resolve => {\n          gsap.fromTo(element, {\n            x: rect.left,\n            y: rect.top,\n            scale: 1,\n            opacity: 1,\n            zIndex: zIndex,\n            rotate: 0,\n            rotateY: 0\n          }, {\n            x: toX - offsetX + elementWidth * (elements.length / 2) / 4,\n            y: toY - elementHeight / 1.2,\n            scale: toScale,\n            opacity: 1,\n            zIndex: 0,\n            rotate: rotation ? -368 : -8,\n            rotateY: 360,\n            duration: duration,\n            delay: delay + index * 0.1,\n            ease: \"power2.out\",\n            onStart: () => {\n              element.style.zIndex = zIndex;\n            },\n            onComplete: () => {\n              openCard(element);\n              cardToSelf(element);\n              element.style.zIndex = zIndex;\n              resolve(); // Разрешаем промис по завершению анимации\n            }\n          });\n        });\n      } else {\n        return Promise.resolve(); // Если элемент не существует, сразу разрешаем промис\n      }\n    });\n    return Promise.all(promises); // Возвращаем промис, который разрешится, когда все анимации завершатся\n  } else {\n    return Promise.resolve(); // Если нет элементов, сразу разрешаем промис\n  }\n};\n\n// Анимация показа козырной карты\nexport const animateShowTrumpCard = element => {\n  return new Promise(resolve => {\n    if (element) {\n      const rect = element.getBoundingClientRect();\n      const currentScale = gsap.getProperty(element, \"scale\");\n      gsap.fromTo(element, {\n        x: rect.x,\n        scale: currentScale,\n        opacity: 1,\n        rotate: 0\n      }, {\n        z: 0,\n        x: rect.x + 20,\n        opacity: 1,\n        rotate: 90,\n        duration: 0.3,\n        delay: 1,\n        ease: \"power2.out\",\n        onComplete: () => {\n          resolve();\n          openCard(element);\n        } // Разрешаем промис по завершению анимации\n      });\n    } else {\n      resolve(); // Если элемент не существует, сразу разрешаем промис\n    }\n  });\n};\n\n//\n\n// Анимация показа козырной карты с эффектом вибрации\nexport const animateVibrateCard = element => {\n  return new Promise(resolve => {\n    if (element) {\n      // Запоминаем начальное положение и масштаб\n      const initialX = gsap.getProperty(element, \"x\");\n      const initialY = gsap.getProperty(element, \"y\");\n      const initialScale = gsap.getProperty(element, \"scale\");\n\n      // Этап 1: Показ карты\n      gsap.fromTo(element, {\n        scale: initialScale,\n        x: initialX,\n        // Начальная позиция для вибрации\n        y: initialY // Начальная позиция для вибрации\n      }, {\n        duration: 0.2,\n        ease: \"power2.out\",\n        onComplete: () => {\n          // Этап 2: Добавление эффекта вибрации без изменения позиции\n          gsap.to(element, {\n            x: initialX + 5,\n            // Вибрация\n            yoyo: true,\n            repeat: 10,\n            // Количество повторений для вибрации\n            duration: 0.05,\n            ease: \"sine.inOut\",\n            onComplete: () => {\n              // Возвращаем элемент в исходное положение\n              gsap.to(element, {\n                x: initialX,\n                duration: 0.1,\n                // Быстрое возвращение\n                ease: \"power1.inOut\",\n                onComplete: () => {\n                  resolve();\n                }\n              });\n            }\n          });\n        }\n      });\n    } else {\n      resolve(); // Если элемент не существует, сразу разрешаем промис\n    }\n  });\n};","map":{"version":3,"names":["gsap","openCard","cardToSelf","animateMoveTo","element","toX","toY","toScale","duration","delay","rotation","Promise","resolve","currentScale","getProperty","currentX","currentY","rect","getBoundingClientRect","fromTo","x","y","scale","opacity","rotate","ease","onComplete","animateGetCardsPlayerSelf","elements","length","promises","map","index","elementWidth","width","elementHeight","height","offsetX","zIndex","left","top","rotateY","onStart","style","all","animateShowTrumpCard","z","animateVibrateCard","initialX","initialY","initialScale","to","yoyo","repeat"],"sources":["C:/Users/smeno/OneDrive/Рабочий стол/dur/src/game/utils/animationUtils.jsx"],"sourcesContent":["import { gsap } from \"gsap\";\r\n// func\r\nimport { openCard, cardToSelf } from \"./cardUtils\";\r\n/**\r\n * Плавное перемещение элемента в заданную позицию с использованием gsap.\r\n * @param {HTMLElement} element - Элемент для анимации.\r\n * @param {number} toX - Конечное значение по оси X.\r\n * @param {number} toY - Конечное значение по оси Y.\r\n * @param {number} [toScale=1] - Конечный масштаб (по умолчанию 1).\r\n * @param {number} duration - Продолжительность анимации.\r\n * @param {number} delay - Задержка перед началом анимации.\r\n */\r\n\r\n// Анимация перемещения карты\r\nexport const animateMoveTo = (\r\n\telement,\r\n\ttoX,\r\n\ttoY,\r\n\ttoScale = 1,\r\n\tduration,\r\n\tdelay,\r\n\trotation = true\r\n) => {\r\n\treturn new Promise((resolve) => {\r\n\t\tif (element) {\r\n\t\t\tconst currentScale = gsap.getProperty(element, \"scale\");\r\n\t\t\tconst currentX = gsap.getProperty(element, \"x\");\r\n\t\t\tconst currentY = gsap.getProperty(element, \"y\");\r\n\r\n\t\t\tconst rect = element.getBoundingClientRect();\r\n\t\t\tgsap.fromTo(\r\n\t\t\t\telement,\r\n\t\t\t\t{\r\n\t\t\t\t\tx: rect.x,\r\n\t\t\t\t\ty: rect.y,\r\n\t\t\t\t\tscale: currentScale,\r\n\t\t\t\t\topacity: 1,\r\n\t\t\t\t\trotate: 0,\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tx: toX == null ? currentX : toX,\r\n\t\t\t\t\ty: toY == null ? currentY : toY,\r\n\t\t\t\t\tscale: toScale,\r\n\t\t\t\t\topacity: 1,\r\n\t\t\t\t\trotate: rotation ? 368 : -8,\r\n\t\t\t\t\tduration: duration,\r\n\t\t\t\t\tdelay: delay,\r\n\t\t\t\t\tease: \"power2.out\",\r\n\t\t\t\t\tonComplete: resolve, // Разрешаем промис по завершению анимации\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tresolve(); // Если элемент не существует, сразу разрешаем промис\r\n\t\t}\r\n\t});\r\n};\r\n\r\n// Анимация получения карт игроком\r\nexport const animateGetCardsPlayerSelf = (\r\n\telements,\r\n\ttoX,\r\n\ttoY,\r\n\ttoScale = 1,\r\n\tduration,\r\n\tdelay = 0,\r\n\trotation = true\r\n) => {\r\n\tif (elements.length > 0) {\r\n\t\tconst promises = elements.map((element, index) => {\r\n\t\t\tif (element) {\r\n\t\t\t\tconst rect = element.getBoundingClientRect();\r\n\t\t\t\tconst elementWidth = rect.width;\r\n\t\t\t\tconst elementHeight = rect.height;\r\n\t\t\t\tconst offsetX = elementWidth * 0.5 * index;\r\n\t\t\t\tconst zIndex = elements.length - index;\r\n\r\n\t\t\t\treturn new Promise((resolve) => {\r\n\t\t\t\t\tgsap.fromTo(\r\n\t\t\t\t\t\telement,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tx: rect.left,\r\n\t\t\t\t\t\t\ty: rect.top,\r\n\t\t\t\t\t\t\tscale: 1,\r\n\t\t\t\t\t\t\topacity: 1,\r\n\t\t\t\t\t\t\tzIndex: zIndex,\r\n\t\t\t\t\t\t\trotate: 0,\r\n\t\t\t\t\t\t\trotateY: 0,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tx: toX - offsetX + (elementWidth * (elements.length / 2)) / 4,\r\n\t\t\t\t\t\t\ty: toY - elementHeight / 1.2,\r\n\t\t\t\t\t\t\tscale: toScale,\r\n\t\t\t\t\t\t\topacity: 1,\r\n\t\t\t\t\t\t\tzIndex: 0,\r\n\t\t\t\t\t\t\trotate: rotation ? -368 : -8,\r\n\t\t\t\t\t\t\trotateY: 360,\r\n\t\t\t\t\t\t\tduration: duration,\r\n\t\t\t\t\t\t\tdelay: delay + index * 0.1,\r\n\t\t\t\t\t\t\tease: \"power2.out\",\r\n\t\t\t\t\t\t\tonStart: () => {\r\n\t\t\t\t\t\t\t\telement.style.zIndex = zIndex;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tonComplete: () => {\r\n\t\t\t\t\t\t\t\topenCard(element);\r\n\t\t\t\t\t\t\t\tcardToSelf(element);\r\n\t\t\t\t\t\t\t\telement.style.zIndex = zIndex;\r\n\t\t\t\t\t\t\t\tresolve(); // Разрешаем промис по завершению анимации\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn Promise.resolve(); // Если элемент не существует, сразу разрешаем промис\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn Promise.all(promises); // Возвращаем промис, который разрешится, когда все анимации завершатся\r\n\t} else {\r\n\t\treturn Promise.resolve(); // Если нет элементов, сразу разрешаем промис\r\n\t}\r\n};\r\n\r\n// Анимация показа козырной карты\r\nexport const animateShowTrumpCard = (element) => {\r\n\treturn new Promise((resolve) => {\r\n\t\tif (element) {\r\n\t\t\tconst rect = element.getBoundingClientRect();\r\n\t\t\tconst currentScale = gsap.getProperty(element, \"scale\");\r\n\r\n\t\t\tgsap.fromTo(\r\n\t\t\t\telement,\r\n\t\t\t\t{\r\n\t\t\t\t\tx: rect.x,\r\n\t\t\t\t\tscale: currentScale,\r\n\t\t\t\t\topacity: 1,\r\n\t\t\t\t\trotate: 0,\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tz: 0,\r\n\t\t\t\t\tx: rect.x + 20,\r\n\t\t\t\t\topacity: 1,\r\n\t\t\t\t\trotate: 90,\r\n\t\t\t\t\tduration: 0.3,\r\n\t\t\t\t\tdelay: 1,\r\n\t\t\t\t\tease: \"power2.out\",\r\n\t\t\t\t\tonComplete: () => {\r\n\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\topenCard(element);\r\n\t\t\t\t\t}, // Разрешаем промис по завершению анимации\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tresolve(); // Если элемент не существует, сразу разрешаем промис\r\n\t\t}\r\n\t});\r\n};\r\n\r\n//\r\n\r\n// Анимация показа козырной карты с эффектом вибрации\r\nexport const animateVibrateCard = (element) => {\r\n\treturn new Promise((resolve) => {\r\n\t\tif (element) {\r\n\t\t\t// Запоминаем начальное положение и масштаб\r\n\t\t\tconst initialX = gsap.getProperty(element, \"x\");\r\n\t\t\tconst initialY = gsap.getProperty(element, \"y\");\r\n\t\t\tconst initialScale = gsap.getProperty(element, \"scale\");\r\n\r\n\t\t\t// Этап 1: Показ карты\r\n\t\t\tgsap.fromTo(\r\n\t\t\t\telement,\r\n\t\t\t\t{\r\n\t\t\t\t\tscale: initialScale,\r\n\t\t\t\t\tx: initialX, // Начальная позиция для вибрации\r\n\t\t\t\t\ty: initialY, // Начальная позиция для вибрации\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tduration: 0.2,\r\n\t\t\t\t\tease: \"power2.out\",\r\n\t\t\t\t\tonComplete: () => {\r\n\t\t\t\t\t\t// Этап 2: Добавление эффекта вибрации без изменения позиции\r\n\t\t\t\t\t\tgsap.to(element, {\r\n\t\t\t\t\t\t\tx: initialX + 5, // Вибрация\r\n\t\t\t\t\t\t\tyoyo: true,\r\n\t\t\t\t\t\t\trepeat: 10, // Количество повторений для вибрации\r\n\t\t\t\t\t\t\tduration: 0.05,\r\n\t\t\t\t\t\t\tease: \"sine.inOut\",\r\n\t\t\t\t\t\t\tonComplete: () => {\r\n\t\t\t\t\t\t\t\t// Возвращаем элемент в исходное положение\r\n\t\t\t\t\t\t\t\tgsap.to(element, {\r\n\t\t\t\t\t\t\t\t\tx: initialX,\r\n\t\t\t\t\t\t\t\t\tduration: 0.1, // Быстрое возвращение\r\n\t\t\t\t\t\t\t\t\tease: \"power1.inOut\",\r\n\t\t\t\t\t\t\t\t\tonComplete: () => {\r\n\t\t\t\t\t\t\t\t\t\tresolve();\r\n\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t},\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tresolve(); // Если элемент не существует, сразу разрешаем промис\r\n\t\t}\r\n\t});\r\n};\r\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,MAAM;AAC3B;AACA,SAASC,QAAQ,EAAEC,UAAU,QAAQ,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,MAAMC,aAAa,GAAGA,CAC5BC,OAAO,EACPC,GAAG,EACHC,GAAG,EACHC,OAAO,GAAG,CAAC,EACXC,QAAQ,EACRC,KAAK,EACLC,QAAQ,GAAG,IAAI,KACX;EACJ,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAK;IAC/B,IAAIR,OAAO,EAAE;MACZ,MAAMS,YAAY,GAAGb,IAAI,CAACc,WAAW,CAACV,OAAO,EAAE,OAAO,CAAC;MACvD,MAAMW,QAAQ,GAAGf,IAAI,CAACc,WAAW,CAACV,OAAO,EAAE,GAAG,CAAC;MAC/C,MAAMY,QAAQ,GAAGhB,IAAI,CAACc,WAAW,CAACV,OAAO,EAAE,GAAG,CAAC;MAE/C,MAAMa,IAAI,GAAGb,OAAO,CAACc,qBAAqB,CAAC,CAAC;MAC5ClB,IAAI,CAACmB,MAAM,CACVf,OAAO,EACP;QACCgB,CAAC,EAAEH,IAAI,CAACG,CAAC;QACTC,CAAC,EAAEJ,IAAI,CAACI,CAAC;QACTC,KAAK,EAAET,YAAY;QACnBU,OAAO,EAAE,CAAC;QACVC,MAAM,EAAE;MACT,CAAC,EACD;QACCJ,CAAC,EAAEf,GAAG,IAAI,IAAI,GAAGU,QAAQ,GAAGV,GAAG;QAC/BgB,CAAC,EAAEf,GAAG,IAAI,IAAI,GAAGU,QAAQ,GAAGV,GAAG;QAC/BgB,KAAK,EAAEf,OAAO;QACdgB,OAAO,EAAE,CAAC;QACVC,MAAM,EAAEd,QAAQ,GAAG,GAAG,GAAG,CAAC,CAAC;QAC3BF,QAAQ,EAAEA,QAAQ;QAClBC,KAAK,EAAEA,KAAK;QACZgB,IAAI,EAAE,YAAY;QAClBC,UAAU,EAAEd,OAAO,CAAE;MACtB,CACD,CAAC;IACF,CAAC,MAAM;MACNA,OAAO,CAAC,CAAC,CAAC,CAAC;IACZ;EACD,CAAC,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMe,yBAAyB,GAAGA,CACxCC,QAAQ,EACRvB,GAAG,EACHC,GAAG,EACHC,OAAO,GAAG,CAAC,EACXC,QAAQ,EACRC,KAAK,GAAG,CAAC,EACTC,QAAQ,GAAG,IAAI,KACX;EACJ,IAAIkB,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;IACxB,MAAMC,QAAQ,GAAGF,QAAQ,CAACG,GAAG,CAAC,CAAC3B,OAAO,EAAE4B,KAAK,KAAK;MACjD,IAAI5B,OAAO,EAAE;QACZ,MAAMa,IAAI,GAAGb,OAAO,CAACc,qBAAqB,CAAC,CAAC;QAC5C,MAAMe,YAAY,GAAGhB,IAAI,CAACiB,KAAK;QAC/B,MAAMC,aAAa,GAAGlB,IAAI,CAACmB,MAAM;QACjC,MAAMC,OAAO,GAAGJ,YAAY,GAAG,GAAG,GAAGD,KAAK;QAC1C,MAAMM,MAAM,GAAGV,QAAQ,CAACC,MAAM,GAAGG,KAAK;QAEtC,OAAO,IAAIrB,OAAO,CAAEC,OAAO,IAAK;UAC/BZ,IAAI,CAACmB,MAAM,CACVf,OAAO,EACP;YACCgB,CAAC,EAAEH,IAAI,CAACsB,IAAI;YACZlB,CAAC,EAAEJ,IAAI,CAACuB,GAAG;YACXlB,KAAK,EAAE,CAAC;YACRC,OAAO,EAAE,CAAC;YACVe,MAAM,EAAEA,MAAM;YACdd,MAAM,EAAE,CAAC;YACTiB,OAAO,EAAE;UACV,CAAC,EACD;YACCrB,CAAC,EAAEf,GAAG,GAAGgC,OAAO,GAAIJ,YAAY,IAAIL,QAAQ,CAACC,MAAM,GAAG,CAAC,CAAC,GAAI,CAAC;YAC7DR,CAAC,EAAEf,GAAG,GAAG6B,aAAa,GAAG,GAAG;YAC5Bb,KAAK,EAAEf,OAAO;YACdgB,OAAO,EAAE,CAAC;YACVe,MAAM,EAAE,CAAC;YACTd,MAAM,EAAEd,QAAQ,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;YAC5B+B,OAAO,EAAE,GAAG;YACZjC,QAAQ,EAAEA,QAAQ;YAClBC,KAAK,EAAEA,KAAK,GAAGuB,KAAK,GAAG,GAAG;YAC1BP,IAAI,EAAE,YAAY;YAClBiB,OAAO,EAAEA,CAAA,KAAM;cACdtC,OAAO,CAACuC,KAAK,CAACL,MAAM,GAAGA,MAAM;YAC9B,CAAC;YACDZ,UAAU,EAAEA,CAAA,KAAM;cACjBzB,QAAQ,CAACG,OAAO,CAAC;cACjBF,UAAU,CAACE,OAAO,CAAC;cACnBA,OAAO,CAACuC,KAAK,CAACL,MAAM,GAAGA,MAAM;cAC7B1B,OAAO,CAAC,CAAC,CAAC,CAAC;YACZ;UACD,CACD,CAAC;QACF,CAAC,CAAC;MACH,CAAC,MAAM;QACN,OAAOD,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;MAC3B;IACD,CAAC,CAAC;IAEF,OAAOD,OAAO,CAACiC,GAAG,CAACd,QAAQ,CAAC,CAAC,CAAC;EAC/B,CAAC,MAAM;IACN,OAAOnB,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;EAC3B;AACD,CAAC;;AAED;AACA,OAAO,MAAMiC,oBAAoB,GAAIzC,OAAO,IAAK;EAChD,OAAO,IAAIO,OAAO,CAAEC,OAAO,IAAK;IAC/B,IAAIR,OAAO,EAAE;MACZ,MAAMa,IAAI,GAAGb,OAAO,CAACc,qBAAqB,CAAC,CAAC;MAC5C,MAAML,YAAY,GAAGb,IAAI,CAACc,WAAW,CAACV,OAAO,EAAE,OAAO,CAAC;MAEvDJ,IAAI,CAACmB,MAAM,CACVf,OAAO,EACP;QACCgB,CAAC,EAAEH,IAAI,CAACG,CAAC;QACTE,KAAK,EAAET,YAAY;QACnBU,OAAO,EAAE,CAAC;QACVC,MAAM,EAAE;MACT,CAAC,EACD;QACCsB,CAAC,EAAE,CAAC;QACJ1B,CAAC,EAAEH,IAAI,CAACG,CAAC,GAAG,EAAE;QACdG,OAAO,EAAE,CAAC;QACVC,MAAM,EAAE,EAAE;QACVhB,QAAQ,EAAE,GAAG;QACbC,KAAK,EAAE,CAAC;QACRgB,IAAI,EAAE,YAAY;QAClBC,UAAU,EAAEA,CAAA,KAAM;UACjBd,OAAO,CAAC,CAAC;UACTX,QAAQ,CAACG,OAAO,CAAC;QAClB,CAAC,CAAE;MACJ,CACD,CAAC;IACF,CAAC,MAAM;MACNQ,OAAO,CAAC,CAAC,CAAC,CAAC;IACZ;EACD,CAAC,CAAC;AACH,CAAC;;AAED;;AAEA;AACA,OAAO,MAAMmC,kBAAkB,GAAI3C,OAAO,IAAK;EAC9C,OAAO,IAAIO,OAAO,CAAEC,OAAO,IAAK;IAC/B,IAAIR,OAAO,EAAE;MACZ;MACA,MAAM4C,QAAQ,GAAGhD,IAAI,CAACc,WAAW,CAACV,OAAO,EAAE,GAAG,CAAC;MAC/C,MAAM6C,QAAQ,GAAGjD,IAAI,CAACc,WAAW,CAACV,OAAO,EAAE,GAAG,CAAC;MAC/C,MAAM8C,YAAY,GAAGlD,IAAI,CAACc,WAAW,CAACV,OAAO,EAAE,OAAO,CAAC;;MAEvD;MACAJ,IAAI,CAACmB,MAAM,CACVf,OAAO,EACP;QACCkB,KAAK,EAAE4B,YAAY;QACnB9B,CAAC,EAAE4B,QAAQ;QAAE;QACb3B,CAAC,EAAE4B,QAAQ,CAAE;MACd,CAAC,EACD;QACCzC,QAAQ,EAAE,GAAG;QACbiB,IAAI,EAAE,YAAY;QAClBC,UAAU,EAAEA,CAAA,KAAM;UACjB;UACA1B,IAAI,CAACmD,EAAE,CAAC/C,OAAO,EAAE;YAChBgB,CAAC,EAAE4B,QAAQ,GAAG,CAAC;YAAE;YACjBI,IAAI,EAAE,IAAI;YACVC,MAAM,EAAE,EAAE;YAAE;YACZ7C,QAAQ,EAAE,IAAI;YACdiB,IAAI,EAAE,YAAY;YAClBC,UAAU,EAAEA,CAAA,KAAM;cACjB;cACA1B,IAAI,CAACmD,EAAE,CAAC/C,OAAO,EAAE;gBAChBgB,CAAC,EAAE4B,QAAQ;gBACXxC,QAAQ,EAAE,GAAG;gBAAE;gBACfiB,IAAI,EAAE,cAAc;gBACpBC,UAAU,EAAEA,CAAA,KAAM;kBACjBd,OAAO,CAAC,CAAC;gBACV;cACD,CAAC,CAAC;YACH;UACD,CAAC,CAAC;QACH;MACD,CACD,CAAC;IACF,CAAC,MAAM;MACNA,OAAO,CAAC,CAAC,CAAC,CAAC;IACZ;EACD,CAAC,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}